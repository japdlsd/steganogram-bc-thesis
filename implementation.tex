\chapter{Implementation}
\label{ch:imple}

In this chapter we will talk about main implementation details of
our application.

\section{How to build the application}
In this section we will show how to build and install our application.

The process is very simple: you have to download all files and open them
in Android Studio. Some of the code is written in C++, so you'd need to 
use NDK if you want to build the application without Android Studio.

The application has been developed and tested on Android OS 4.4 .

\section{Overview of the design}
In this section we will show the general architecture of the application
and describe the main parts.

Our goal was to separate the interface and internal logic. We've achiveved that
by creating ``junction'' class \texttt{Solution}, which has been inserted between
Android-specific interface code and steganographic core, so that code, responsing for
the interface, is working only with this layer.

Now we will walk through all major functions of our application and describe what is going on inside.

\subsection{Embedding process}

An user types a secret message he wants to embed into an image. Then he takes a photo with 
phone's camera. Then he clicks a button ``Start embedding''. The program checks, whether 
an image is accessible, and then calls function \texttt{Solution.embed()}.

\texttt{Solution} object decodes a string with the secret message into a byte array,
compress it, encrypts it and then calls a function \texttt{info.guardianproject.f5android.Embed()},
which we borrowed from another open-source steganographic application \emph{Pixelknot} by Guardian
Project (mailny the correct implementation of encoding/decoding images into and from the JPEG format). 
This function extract DCT coefficients from the taken image,  applies our steganographic
algorithm, implemented as \texttt{DCTsteganographyCERep} class, and then envelops the changed coefficients
back to the cover image, which is then saved into the phone's Gallery.

\subsection{Extracting process}

An user chooses an image with embedded image from a Gallery and clicks on ``Start extracting'' button.
The program calls function \texttt{Solution.extract()}.

\texttt{Solution} object sends the image into the \texttt{info.guardianproject.f5android.Extract()} function,
which extracts DCT coefficients from the image and then applies the reverse pipeline: calls the extraction
function \texttt{DCTSteganographyCERep.extract()}, which returns the embedded bytes, then decrypt
and decompress them. Then the \texttt{Solution} object calls the callback function with the resulting
message back into the interface code, which shows it on the display.

\section{Algorithms' settings}
In this section we will show concrete parameters of all used algorithms.

\subsubsection{Steganographic algorithm CE}

\paragraph{Separation ratio $\alpha$} We've chosen the same value as in the 
paper: $0.8$.

\paragraph{Adjustment parameter $\beta$} We've chosen the same value as in the paper: $\frac{1}{3}$.

\paragraph{Length of a message}
We've set maximum length of a block as 2 byte word, so the maximum length is 
$2^{16} = 65536$ bytes. Therefore, the maximum length of embedded message is 
$2^{16} (2 - \alpha) = 2^{16} (2 - 0.8) = 78643$ bytes.

\subsubsection{Cryptographic algorithm AES}

We use AES-256 algorithm in CBC mode with a random initial vector (IV), implemented by 
the library \texttt{com.scottyab.aescrypt.AESCrypt}.

\subsubsection{Secret passwords generation}
Both steganographic and cryptographic passwords are arbitrary UTF-8 strings. We create 
them by generating 60 random bytes with \texttt{SecureRandom} class from the standard
Java library \texttt{java.security} and then encoding them into \emph{Base64} strings.
We've chosen the length of the passwords to be divisible by $3$ so that the resulting
Base64 string would not have a padding. 
You can read more about Base64 enoding here \cite{josefsson2006base16}.

We've chosen the Base64 encoding as it encodes the bytes into the most common set
of printable characters and is faster (and easier to implement correctly) 
than performing a random pick from a set based on random bytes.

Cryptographic key is derived from a cryptographic password by \texttt{AESCrypt}
library. Steganographic algorithm uses stego password as a seed for random generator.

\subsubsection{Compression algorithm GZIP}

We use default Java library classes for GZIP compression with default settings.

\section{Testing the steganographic algorithm}

We decided to test whether the main parts of the steganographic algorithm
are correct, i.e. whether the paired transformations are mutually inverse.

The steganographic algorithm has three main pairs of transformation functions:
\begin{itemize}
    \item \texttt{encodeBits2Byte} and \texttt{encodeByte2Bits} 
        --- encoding a byte as a bit array (little endian encoding)
    \item \texttt{encodeInt2Bytes} and \texttt{encodeBytes2Int}
        --- encoding an integer as a byte array of a fixed length
    \item \texttt{embedBit} and \texttt{extractBit} 
        --- embedding a secret bit into a DCT coefficient and vice versa
        according to our steganographic algorithm
\end{itemize}

As the functions has only small finite amount of possible inputs, we've decided
to test their mutual inversibility exhaustively (i.e. on every possible input).

During the tests, we've found that the embedding algorithm from the original
paper \cite{liu2008high} was incorrect. We've been able to pinpoint and correct
the error thanks to a decription of the inverse process in the paper. In this 
paper we give the correct implementation of this algorithm (and by that we mean
that the functions \texttt{embedBit} and \texttt{extractBit} are mutually inverse).
You can find the description of the error in the listing in the subsection \ref{sssec:therory-embedding}.

\section{How to replace used algorithms}
In this section we will decribe the interfaces of used algorithms.

\subsubsection{Steganographic algorithm interface}
\texttt{DCTSteganography} interface has four functions.

Function \texttt{loadKeyFromString} takes one argument --- 
a string representation of a steganographic key. It returns
\texttt{true} if the key was successfully extracted and
\texttt{false} otherwise.

Function \texttt{generateStegoKeyString} returns a 
valid string representation of a newly created steganographic key 
(this string should be parseable by function \texttt{loadKeyFromString}).

Function \texttt{embed} takes two arguments: an integer array \texttt{coeffOrig}
representing quantized DCT coefficients of a cover image and an \texttt{InputStream} 
with bytes of a secret message we want to embed into the cover image. 
This function returns nothing, but it embeds the secret message into
the DCT coefficients. 

Function \texttt{extract} takes two arguments: an integer array \texttt{coeffOrig}
representing qunatized DCT coefficients of a cover image with embedded message
and an \texttt{ExtractionListener} that have to be called with the extracted message
as an argument.

\begin{lstlisting} 
public interface DCTSteganography {
    boolean loadKeyFromString (final String s);
    String generateStegoKeyString ();

    void embed (int[] coeffOrig, 
            final InputStream embeddedData);

    void extract (int[] coeffOrig,  
            ByteArrayOutputStream fos, Extract.ExtractionListener listener);
}
\end{lstlisting}

\subsubsection{Cryptographic algorithm interface}
\texttt{SymmetricEncryption} interface has four functions.

Function \texttt{loadKeyFromString} takes one argument --- 
a string representation of a cryptographic key. It returns
\texttt{true} if the key was successfully extracted and
\texttt{false} otherwise.

Function \texttt{generateCryptoKeyString} returns a 
valid string representation of a newly created cryptographic key 
(this string should be parseable by function \texttt{loadKeyFromString}).

Function \texttt{encrypt} takes one argument --- a byte array that represents
a message to be encrypted and returns a byte array representing the encrypted
message.

Function \texttt{decrypt} takes one argument --- a byte array that represents
an encrypted message and returns a byte array representing the original message.
\pagebreak
\begin{lstlisting}
public interface SymmetricEncryption {
    boolean loadKeyFromString (final String s);
    String generateCryptoKeyString ();
    byte[] encrypt (byte[] text);
    byte[] decrypt (byte[] message);
}
\end{lstlisting}

\subsubsection{Compression algorithm interface}

\texttt{Compression} interface has two functions:
\texttt{compress} and \texttt{decompress}. 

Function \texttt{compress}
takes one argument --- a~byte~array representing a~message and returns
a~byte~array with compressed message. 

Function \texttt{decompress}
takes one argument~---~a~byte~array representing a~compressed message
and returns a~byte~array with an~original message.

\begin{lstlisting} 
public interface Compression {
    byte[] compress (byte[] message);
    byte[] decompress (byte[] message);
}
\end{lstlisting}
